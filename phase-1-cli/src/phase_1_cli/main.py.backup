"""
Interactive CLI Todo Application
Built with Textual framework for beautiful, interactive terminal UI
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import List, Optional

import pyfiglet
from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Container, Horizontal
from textual.screen import ModalScreen
from textual.widgets import (
    Button,
    DataTable,
    Footer,
    Header,
    Input,
    Static,
    Select,
)


# ============================================================================
# Data Models (Business Logic - Decoupled from UI)
# ============================================================================

class Priority(Enum):
    """Task priority levels"""
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"


class Recurrence(Enum):
    """Task recurrence patterns"""
    NONE = "None"
    DAILY = "Daily"
    WEEKLY = "Weekly"
    MONTHLY = "Monthly"


@dataclass
class Task:
    """Represents a single todo task"""
    id: int
    title: str
    description: str = ""
    completed: bool = False
    created_at: datetime = field(default_factory=datetime.now)
    priority: Priority = Priority.MEDIUM
    category: str = None
    due_date: datetime = None
    recurrence: Recurrence = Recurrence.NONE
    completed_at: datetime = None

    def __str__(self) -> str:
        status = "[x]" if self.completed else "[ ]"
        return f"{status} {self.title}"


class TaskManager:
    """Manages todo tasks with in-memory storage only"""

    def __init__(self):
        self.tasks: List[Task] = []
        self.next_id = 1

    def add_task(
        self,
        title: str,
        description: str = "",
        priority: Priority = Priority.MEDIUM,
        category: str = None,
        due_date: datetime = None,
        recurrence: Recurrence = Recurrence.NONE
    ) -> Task:
        """Add a new task"""
        title = title.strip()
        description = description.strip()

        if not title:
            raise ValueError("Title cannot be empty")

        task = Task(
            id=self.next_id,
            title=title,
            description=description,
            priority=priority,
            category=category,
            due_date=due_date,
            recurrence=recurrence
        )
        self.tasks.append(task)
        self.next_id += 1
        return task

    def get_task(self, task_id: int) -> Optional[Task]:
        """Get task by ID"""
        return next((t for t in self.tasks if t.id == task_id), None)

    def update_task(
        self,
        task_id: int,
        title: str = None,
        description: str = None,
        priority: Priority = None,
        category: str = None,
        due_date: datetime = None,
        recurrence: Recurrence = None
    ) -> bool:
        """Update task fields"""
        task = self.get_task(task_id)
        if not task:
            return False

        if title is not None:
            title = title.strip()
            if not title:
                raise ValueError("Title cannot be empty")
            task.title = title

        if description is not None:
            task.description = description.strip()

        if priority is not None:
            task.priority = priority

        if category is not None:
            task.category = category

        if due_date is not None:
            task.due_date = due_date

        if recurrence is not None:
            task.recurrence = recurrence

        return True

    def delete_task(self, task_id: int) -> bool:
        """Delete a task"""
        task = self.get_task(task_id)
        if task:
            self.tasks.remove(task)
            return True
        return False

    def toggle_task(self, task_id: int) -> Optional[Task]:
        """Toggle task completion status, create next instance for recurring tasks"""
        task = self.get_task(task_id)
        if not task:
            return None

        # Mark as complete or incomplete
        if not task.completed:
            task.completed = True
            task.completed_at = datetime.now()

            # Handle recurrence: create next instance
            if task.recurrence != Recurrence.NONE and task.due_date:
                next_due_date = self._calculate_next_due_date(task.due_date, task.recurrence)
                new_task = Task(
                    id=self.next_id,
                    title=task.title,
                    description=task.description,
                    priority=task.priority,
                    category=task.category,
                    due_date=next_due_date,
                    recurrence=task.recurrence
                )
                self.tasks.append(new_task)
                self.next_id += 1
                return new_task  # Return the new recurring task
        else:
            # Reopen task - clear completed timestamp
            task.completed = False
            task.completed_at = None

        return task

    def get_stats(self) -> dict:
        """Calculate task statistics"""
        total = len(self.tasks)
        completed = sum(1 for t in self.tasks if t.completed)
        pending = total - completed
        percentage = (completed / total * 100) if total > 0 else 0.0

        return {
            "total": total,
            "completed": completed,
            "pending": pending,
            "percentage": percentage
        }

    def search_tasks(self, keyword: str) -> List[Task]:
        """Find tasks matching keyword in title or description"""
        if not keyword:
            return self.tasks.copy()

        keyword_lower = keyword.lower()
        return [
            t for t in self.tasks
            if keyword_lower in t.title.lower() or keyword_lower in t.description.lower()
        ]

    def filter_tasks(
        self,
        status: bool = None,
        priority: Priority = None,
        category: str = None,
        due_date_filter: str = None
    ) -> List[Task]:
        """Filter tasks by multiple criteria using AND logic"""
        filtered_tasks = self.tasks.copy()

        if status is not None:
            filtered_tasks = [t for t in filtered_tasks if t.completed == status]

        if priority is not None:
            filtered_tasks = [t for t in filtered_tasks if t.priority == priority]

        if category is not None:
            filtered_tasks = [t for t in filtered_tasks if t.category == category]

        if due_date_filter == "due_today":
            today = datetime.now().date()
            filtered_tasks = [t for t in filtered_tasks if t.due_date and t.due_date.date() == today]
        elif due_date_filter == "upcoming":
            now = datetime.now()
            one_week = now + timedelta(days=7)
            filtered_tasks = [t for t in filtered_tasks if t.due_date and now <= t.due_date <= one_week]
        elif due_date_filter == "overdue":
            now = datetime.now()
            filtered_tasks = [t for t in filtered_tasks if t.due_date and t.due_date < now and not t.completed]

        return filtered_tasks

    def sort_tasks(self, tasks: List[Task] = None, by: str = "created_at") -> List[Task]:
        """Sort tasks by specified criteria"""
        if tasks is None:
            tasks = self.tasks.copy()

        if by == "priority":
            priority_order = {Priority.HIGH: 0, Priority.MEDIUM: 1, Priority.LOW: 2}
            return sorted(tasks, key=lambda t: (priority_order.get(t.priority, 99), -t.id))
        elif by == "due_date":
            return sorted(tasks, key=lambda t: (t.due_date or datetime.max, t.created_at))
        elif by == "title":
            return sorted(tasks, key=lambda t: t.title.lower())
        elif by == "created_at":
            return sorted(tasks, key=lambda t: t.created_at, reverse=True)
        else:
            return tasks

    def get_overdue_and_upcoming(self) -> dict:
        """Calculate tasks due soon or overdue"""
        now = datetime.now()
        one_day = now + timedelta(days=1)

        overdue = [t for t in self.tasks if t.due_date and t.due_date < now and not t.completed]
        upcoming = [t for t in self.tasks if t.due_date and now <= t.due_date <= one_day and not t.completed]

        return {
            "overdue": overdue,
            "upcoming": upcoming,
            "count": len(overdue) + len(upcoming)
        }

    def _calculate_next_due_date(self, due_date: datetime, recurrence: Recurrence) -> datetime:
        """Calculate next due date based on recurrence pattern"""
        if recurrence == Recurrence.DAILY:
            return due_date + timedelta(days=1)
        elif recurrence == Recurrence.WEEKLY:
            return due_date + timedelta(weeks=1)
        elif recurrence == Recurrence.MONTHLY:
            # Add one month (handles year rollover)
            year = due_date.year + ((due_date.month + 1 - 1) // 12)
            month = (due_date.month + 1 - 1) % 12 + 1
            day = min(due_date.day, [31, 29 if year % 4 == 0 else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1])
            return due_date.replace(year=year, month=month, day=day)
        return due_date


# ============================================================================
# UI Components (Screens and Modals)
# ============================================================================

class AddTaskScreen(ModalScreen[dict]):
    """Modal screen for adding a new task"""

    CSS = """
    AddTaskScreen {
        align: center middle;
    }

    #dialog {
        width: 60;
        height: auto;
        border: solid $primary;
        background: $surface;
        padding: 2;
    }

    .dialog-title {
        text-align: center;
        text-style: bold;
        color: $primary;
        padding-bottom: 1;
    }

    Input, Select {
        margin: 1 0;
    }

    Horizontal {
        align: center middle;
        height: auto;
    }

    Button {
        margin: 0 1;
    }
    """

    BINDINGS = [
        Binding("escape", "cancel", "Cancel"),
    ]

    def compose(self) -> ComposeResult:
        with Container(id="dialog"):
            yield Static("âœ¨ Add New Task", classes="dialog-title")
            yield Input(placeholder="Task title (required)", id="title")
            yield Input(placeholder="Description (optional)", id="description")
            yield Select(
                options=[
                    ("High Priority", Priority.HIGH),
                    ("Medium Priority", Priority.MEDIUM),
                    ("Low Priority", Priority.LOW),
                ],
                value=Priority.MEDIUM,
                id="priority"
            )
            yield Input(placeholder="Category (optional)", id="category")
            yield Select(
                options=[
                    ("None", Recurrence.NONE),
                    ("Daily", Recurrence.DAILY),
                    ("Weekly", Recurrence.WEEKLY),
                    ("Monthly", Recurrence.MONTHLY),
                ],
                value=Recurrence.NONE,
                id="recurrence"
            )
            yield Horizontal(
                Button("Add", variant="success", id="add"),
                Button("Cancel", variant="default", id="cancel")
            )

    def on_mount(self) -> None:
        self.query_one("#title", Input).focus()

    def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "add":
            title = self.query_one("#title", Input).value.strip()
            description = self.query_one("#description", Input).value.strip()
            priority = self.query_one("#priority", Select).value
            category = self.query_one("#category", Input).value.strip() or None
            recurrence = self.query_one("#recurrence", Select).value

            if not title:
                return

            self.dismiss({
                "title": title,
                "description": description,
                "priority": priority,
                "category": category,
                "recurrence": recurrence
            })
        else:
            self.dismiss(None)

    def action_cancel(self) -> None:
        self.dismiss(None)


class EditTaskScreen(ModalScreen[dict]):
    """Modal screen for editing an existing task"""

    CSS = """
    EditTaskScreen {
        align: center middle;
    }

    #dialog {
        width: 60;
        height: auto;
        border: solid $accent;
        background: $surface;
        padding: 2;
    }

    .dialog-title {
        text-align: center;
        text-style: bold;
        color: $accent;
        padding-bottom: 1;
    }

    Input, Select {
        margin: 1 0;
    }

    Horizontal {
        align: center middle;
        height: auto;
    }

    Button {
        margin: 0 1;
    }
    """

    BINDINGS = [
        Binding("escape", "cancel", "Cancel"),
    ]

    def __init__(self, task: Task):
        super().__init__()
        self._todo_task = task

    def compose(self) -> ComposeResult:
        with Container(id="dialog"):
            yield Static("âœï¸ Edit Task", classes="dialog-title")
            yield Input(
                value=self._todo_task.title,
                placeholder="Task title",
                id="title"
            )
            yield Input(
                value=self._todo_task.description,
                placeholder="Description",
                id="description"
            )
            yield Select(
                options=[
                    ("High Priority", Priority.HIGH),
                    ("Medium Priority", Priority.MEDIUM),
                    ("Low Priority", Priority.LOW),
                ],
                value=self._todo_task.priority,
                id="priority"
            )
            yield Input(
                value=self._todo_task.category or "",
                placeholder="Category",
                id="category"
            )
            yield Select(
                options=[
                    ("None", Recurrence.NONE),
                    ("Daily", Recurrence.DAILY),
                    ("Weekly", Recurrence.WEEKLY),
                    ("Monthly", Recurrence.MONTHLY),
                ],
                value=self._todo_task.recurrence,
                id="recurrence"
            )
            yield Horizontal(
                Button("Save", variant="primary", id="save"),
                Button("Cancel", variant="default", id="cancel")
            )

    def on_mount(self) -> None:
        self.query_one("#title", Input).focus()

    def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "save":
            title = self.query_one("#title", Input).value.strip()
            description = self.query_one("#description", Input).value.strip()
            priority = self.query_one("#priority", Select).value
            category = self.query_one("#category", Input).value.strip() or None
            recurrence = self.query_one("#recurrence", Select).value

            if not title:
                return

            self.dismiss({
                "title": title,
                "description": description,
                "priority": priority,
                "category": category,
                "recurrence": recurrence
            })
        else:
            self.dismiss(None)

    def action_cancel(self) -> None:
        self.dismiss(None)


class ConfirmDialog(ModalScreen[bool]):
    """Generic confirmation dialog"""

    CSS = """
    ConfirmDialog {
        align: center middle;
    }

    #dialog {
        width: 50;
        height: auto;
        border: solid $error;
        background: $surface;
        padding: 2;
    }

    .dialog-title {
        text-align: center;
        text-style: bold;
        color: $error;
        padding-bottom: 1;
    }

    .dialog-message {
        text-align: center;
        padding: 1 0;
    }

    Horizontal {
        align: center middle;
        height: auto;
    }

    Button {
        margin: 0 1;
    }
    """

    BINDINGS = [
        Binding("escape", "cancel", "Cancel"),
    ]

    def __init__(self, title: str, message: str):
        super().__init__()
        self.title_text = title
        self.message_text = message

    def compose(self) -> ComposeResult:
        with Container(id="dialog"):
            yield Static(self.title_text, classes="dialog-title")
            yield Static(self.message_text, classes="dialog-message")
            yield Horizontal(
                Button("Confirm", variant="error", id="confirm"),
                Button("Cancel", variant="default", id="cancel")
            )

    def on_button_pressed(self, event: Button.Pressed) -> None:
        self.dismiss(event.button.id == "confirm")

    def action_cancel(self) -> None:
        self.dismiss(False)


# ============================================================================
# Main Application
# ============================================================================

class TodoApp(App):
    """Modern Terminal Todo Application"""

    CSS = """
    Screen {
        background: $surface;
    }

    #banner {
        height: auto;
        background: $primary;
        color: $text;
        text-align: center;
        padding: 1;
        border: solid $accent;
    }

    #stats {
        height: 3;
        background: $panel;
        border: solid $secondary;
        padding: 1;
        text-align: center;
        color: $text;
    }

    DataTable {
        height: 1fr;
        border: solid $primary;
        margin: 1 0;
    }

    .completed {
        text-style: strike;
        color: $success;
    }

    .pending {
        color: $text;
    }
    """

    BINDINGS = [
        Binding("a", "add_task", "Add Task", show=True),
        Binding("e", "edit_task", "Edit", show=True),
        Binding("d", "delete_task", "Delete", show=True),
        Binding("space", "toggle_task", "Toggle", show=True),
        Binding("q", "quit", "Quit", show=True),
    ]

    def __init__(self):
        super().__init__()
        self.task_manager = TaskManager()

    def compose(self) -> ComposeResult:
        # Create ASCII art banner
        banner_text = pyfiglet.figlet_format("Toony 2do", font="slant")
        yield Header(show_clock=True)
        yield Static(banner_text, id="banner")
        yield Static(id="stats")
        yield DataTable(zebra_stripes=True, cursor_type="row")
        yield Footer()

    def on_mount(self) -> None:
        """Initialize the app"""
        table = self.query_one(DataTable)
        table.add_columns("ID", "Status", "Title", "Description")
        table.focus()

        self.refresh_ui()

    def refresh_ui(self) -> None:
        """Refresh the entire UI"""
        self.refresh_table()
        self.refresh_stats()

    def refresh_table(self) -> None:
        """Update the task table"""
        table = self.query_one(DataTable)
        table.clear()

        for task in self.task_manager.tasks:
            status = "[x]" if task.completed else "[ ]"
            style = "completed" if task.completed else "pending"

            table.add_row(
                str(task.id),
                status,
                task.title,
                task.description,
                key=str(task.id)
            )

    def refresh_stats(self) -> None:
        """Update the statistics display"""
        stats = self.task_manager.get_stats()
        stats_widget = self.query_one("#stats", Static)

        stats_widget.update(
            f"Stats Total: {stats['total']} | "
            f"[Pending] Pending: {stats['pending']} | "
            f"[OK] Completed: {stats['completed']} | "
            f"[Progress] Progress: {stats['percentage']:.1f}%"
        )

    def action_add_task(self) -> None:
        """Add a new task"""
        def handle_result(result: dict | None) -> None:
            if result:
                try:
                    self.task_manager.add_task(
                        result["title"],
                        result["description"]
                    )
                    self.refresh_ui()
                except ValueError as e:
                    # Handle validation error (empty title)
                    pass

        self.push_screen(AddTaskScreen(), handle_result)

    def action_edit_task(self) -> None:
        """Edit the selected task"""
        table = self.query_one(DataTable)
        if table.cursor_row is None:
            return

        row_key = table.get_row_at(table.cursor_row)[0]
        task = self.task_manager.get_task(int(row_key))

        if not task:
            return

        def handle_result(result: dict | None) -> None:
            if result:
                try:
                    self.task_manager.update_task(
                        task.id,
                        result["title"],
                        result["description"]
                    )
                    self.refresh_ui()
                except ValueError as e:
                    pass

        self.push_screen(EditTaskScreen(task), handle_result)

    def action_delete_task(self) -> None:
        """Delete the selected task with confirmation"""
        table = self.query_one(DataTable)
        if table.cursor_row is None:
            return

        row_key = table.get_row_at(table.cursor_row)[0]
        task = self.task_manager.get_task(int(row_key))

        if not task:
            return

        def handle_confirm(confirmed: bool) -> None:
            if confirmed:
                self.task_manager.delete_task(task.id)
                self.refresh_ui()

        self.push_screen(
            ConfirmDialog(
                "Delete Task",
                f"Delete '{task.title}'?"
            ),
            handle_confirm
        )

    def action_toggle_task(self) -> None:
        """Toggle completion status of selected task"""
        table = self.query_one(DataTable)
        if table.cursor_row is None:
            return

        row_key = table.get_row_at(table.cursor_row)[0]
        task_id = int(row_key)

        self.task_manager.toggle_task(task_id)
        self.refresh_ui()


# ============================================================================
# CLI Commands (Typer Interface)
# ============================================================================

# Shared task manager for CLI operations
cli_task_manager = TaskManager()


@cli_app.command("ui")
def launch_ui():
    """Launch the interactive TUI (Text User Interface)"""
    console.print(pyfiglet.figlet_format("Toony 2do", font="slant"), style="bold cyan")
    console.print("Launching interactive UI...\n", style="green")
    app = TodoApp()
    app.run()


@cli_app.command("add")
def add_task_cli(
    title: str = typer.Argument(..., help="Task title"),
    description: str = typer.Option("", "--desc", "-d", help="Task description")
):
    """Add a new task from the command line"""
    try:
        task = cli_task_manager.add_task(title, description)
        console.print(f"[OK] Task added: {task.title}", style="bold green")
        console.print(f"   ID: {task.id}", style="dim")
        if description:
            console.print(f"   Description: {description}", style="dim")
    except ValueError as e:
        console.print(f"[ERROR] Error: {e}", style="bold red")
        raise typer.Exit(1)


@cli_app.command("list")
def list_tasks_cli(
    completed: bool = typer.Option(None, "--completed", "-c", help="Show only completed tasks"),
    pending: bool = typer.Option(None, "--pending", "-p", help="Show only pending tasks")
):
    """List all tasks"""
    tasks = cli_task_manager.tasks

    # Filter tasks based on flags
    if completed:
        tasks = [t for t in tasks if t.completed]
    elif pending:
        tasks = [t for t in tasks if not t.completed]

    if not tasks:
        console.print("No tasks No tasks found.", style="yellow")
        return

    # Create rich table
    table = RichTable(title="ðŸ“‹ Tasks", show_header=True, header_style="bold magenta")
    table.add_column("ID", style="cyan", justify="right")
    table.add_column("Status", justify="center")
    table.add_column("Title", style="white")
    table.add_column("Description", style="dim")

    for task in tasks:
        status = "[x]" if task.completed else "[ ]"
        status_style = "green" if task.completed else "yellow"
        table.add_row(
            str(task.id),
            f"[{status_style}]{status}[/{status_style}]",
            task.title,
            task.description
        )

    console.print(table)

    # Show stats
    stats = cli_task_manager.get_stats()
    console.print(
        f"\nStats Total: {stats['total']} | "
        f"[Pending] Pending: {stats['pending']} | "
        f"[OK] Completed: {stats['completed']} | "
        f"[Progress] Progress: {stats['percentage']:.1f}%",
        style="bold"
    )


@cli_app.command("complete")
def complete_task_cli(task_id: int = typer.Argument(..., help="Task ID to mark as complete")):
    """Mark a task as completed"""
    if not cli_task_manager.toggle_task(task_id):
        console.print(f"[ERROR] Task {task_id} not found", style="bold red")
        raise typer.Exit(1)

    task = cli_task_manager.get_task(task_id)
    console.print(f"[OK] Task {task_id} marked as complete: {task.title}", style="bold green")


@cli_app.command("delete")
def delete_task_cli(
    task_id: int = typer.Argument(..., help="Task ID to delete"),
    yes: bool = typer.Option(False, "--yes", "-y", help="Skip confirmation")
):
    """Delete a task"""
    task = cli_task_manager.get_task(task_id)
    if not task:
        console.print(f"[ERROR] Task {task_id} not found", style="bold red")
        raise typer.Exit(1)

    if not yes:
        confirm = typer.confirm(f"Delete task '{task.title}'?")
        if not confirm:
            console.print("Cancelled.", style="yellow")
            raise typer.Exit(0)

    cli_task_manager.delete_task(task_id)
    console.print(f"[DELETED] Task {task_id} deleted", style="bold red")


@cli_app.command("stats")
def show_stats_cli():
    """Show task statistics"""
    stats = cli_task_manager.get_stats()

    console.print(pyfiglet.figlet_format("STATS", font="banner3"), style="bold blue")
    console.print(f"Stats Total Tasks: {stats['total']}", style="bold")
    console.print(f"[Pending] Pending: {stats['pending']}", style="yellow")
    console.print(f"[OK] Completed: {stats['completed']}", style="green")
    console.print(f"[Progress] Progress: {stats['percentage']:.1f}%", style="cyan")


def run() -> None:
    """Entry point - launch TUI directly"""
    console.print(pyfiglet.figlet_format("Toony 2do", font="slant"), style="bold cyan")
    console.print("Launching interactive UI...\n", style="green")
    app = TodoApp()
    app.run()


if __name__ == "__main__":
    cli_app()
